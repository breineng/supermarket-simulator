# Active Context - Date: 2024-12-03

## ✅ КРИТИЧЕСКИЙ БАГФИКС: Исправлен дублирующий скан товаров на кассе (2024-12-03)

**Найден и исправлен критический баг в системе кассы:** Товары можно было сканировать бесконечно, что позволяло получать неограниченные деньги за один товар.

**Проблема:** После сканирования товар перелетал в зону выдачи, но оставался на слое `ScannableItem` и мог быть отсканирован повторно.

**Корневые причины:**
1. **Отсутствие проверки дублирования:** Метод `PlayerAttemptScan()` не проверял, был ли товар уже отсканирован
2. **Неправильное управление слоями:** Отсканированные товары оставались на слое `ScannableItem`
3. **Отсутствие защиты в подсветке:** Система highlighting подсвечивала уже отсканированные товары

**Исправления в `CashDeskController.cs`:**

### 1. Добавлена проверка дублирования в `PlayerAttemptScan()`:
```csharp
// КРИТИЧЕСКИЙ БАГФИКС: Проверяем, что товар еще не был отсканирован
if (_scannedItems.Contains(itemToScan))
{
    Debug.LogWarning($"Item {itemToScan.name} is already scanned! Ignoring duplicate scan attempt.");
    return;
}
```

### 2. Создан метод `ChangeItemLayerToNonScannable()`:
```csharp
private void ChangeItemLayerToNonScannable(GameObject item)
{
    // Изменяем слой на Default, чтобы товар больше не мог быть отсканирован
    item.layer = LayerMask.NameToLayer("Default");
    
    // Также изменяем слой всех дочерних объектов
    foreach (Transform child in item.transform)
    {
        child.gameObject.layer = LayerMask.NameToLayer("Default");
    }
}
```

### 3. Мгновенное изменение слоя при сканировании:
- Слой товара изменяется **до** анимации перелета
- Это предотвращает повторное сканирование во время анимации

### 4. Улучшенная система подсветки в `HandleHighlighting()`:
```csharp
// КРИТИЧЕСКИЙ БАГФИКС: Проверяем, что товар еще не был отсканирован
GameObject hitItem = outlineController.gameObject;
if (_scannedItems.Contains(hitItem))
{
    // Этот товар уже отсканирован, не подсвечиваем его
    return;
}
```

### 5. Улучшенное логирование для отладки:
- Детальное логирование в `ClearBelt()`, `FinishTransaction()`
- Префикс `[ScanningBugFix]` для отслеживания исправлений

**Принцип работы после исправления:**
1. **Сканирование:** Товар проверяется на дублирование
2. **Блокировка:** Слой немедленно изменяется на `Default`
3. **Анимация:** Товар перелетает в зону выдачи
4. **Защита:** Система больше не реагирует на этот товар
5. **Очистка:** Все товары правильно уничтожаются после транзакции

**Результат:**
- ✅ Невозможно отсканировать товар повторно
- ✅ Система highlighting игнорирует отсканированные товары  
- ✅ Правильное управление слоями объектов
- ✅ Детальное логирование для мониторинга
- ✅ Экономическая система защищена от абьюза

## ✅ НОВАЯ ФИЧА: Система перемещения размещенных объектов (клавиша R)

**Реализована система перемещения уже размещенных PlacedObject:** Игроки теперь могут перемещать любые размещенные объекты нажатием клавиши R. Система работает аналогично обычному размещению, но без необходимости иметь коробку в руках.

**Компоненты системы:**

### 1. PlacedObjectRelocator - Новый компонент для обработки клавиши R
- Выполняет raycast по центру экрана для поиска размещенных объектов
- Проверяет объекты по тегу "PlacedObject" (правильный подход вместо проверки имен)
- Активирует режим перемещения через `IPlacementService.StartRelocateMode()`
- Работает только в игровом режиме (InputMode.Game)
- Интегрируется с системой dependency injection через `[Inject]`

### 2. Расширенный IPlacementService
**Новые методы:**
- `StartRelocateMode(GameObject objectToRelocate)` - начинает режим перемещения объекта
- `IsInRelocateMode { get; }` - свойство для проверки режима перемещения
- `GetRelocatingObject()` - получает объект, который сейчас перемещается

### 3. Обновленный PlacementService
**Новые переменные состояния:**
- `_isInRelocateMode` - флаг режима перемещения
- `_relocatingObject` - ссылка на перемещаемый объект
- `_relocatingObjectData` - данные перемещаемого объекта для сохранения
- `_relocatingObjectIndex` - индекс объекта в списке размещенных объектов

**Новая логика:**
- `StartRelocateMode()` - скрывает оригинальный объект и создает превью для перемещения
- `ConfirmRelocation()` - перемещает объект в новую позицию и обновляет данные сохранения
- `CancelRelocateMode()` - отменяет перемещение и показывает объект обратно
- Интеграция с существующими методами `ConfirmPlacement()` и `CancelPlacementMode()`

### 4. Обновленный PlacementController
- `ShouldUpdatePlacement()` теперь работает как в режиме размещения, так и в режиме перемещения
- Система управления (ЛКМ для подтверждения, ПКМ для отмены, прокрутка для поворота) работает одинаково

### 5. Новое действие ввода "RelocateObject"
**В PlayerInputActions.inputactions:**
- Добавлено действие "RelocateObject" с привязкой к клавише R
- ID: "e8f4b1c2-3d6e-4a57-8901-234567890abc"
- Путь: "<Keyboard>/r"

**Принцип работы:**
1. **Активация:** Игрок наводится на размещенный объект и нажимает R
2. **Превью:** Оригинальный объект скрывается, создается превью для перемещения
3. **Позиционирование:** Превью следует за курсором, как при обычном размещении
4. **Подтверждение:** ЛКМ перемещает объект в новую позицию
5. **Отмена:** ПКМ возвращает объект в исходную позицию

**Интеграция с сохранениями:**
- Данные размещенных объектов обновляются при перемещении
- Позиция и поворот сохраняются в `PlacedObjectData`
- Размещенные и восстановленные объекты автоматически получают тег "PlacedObject"
- Полная совместимость с системой save/load

## ✅ НОВАЯ ФИЧА: Система приоритетов obstacle avoidance для клиентов

**Реализована система случайных/уникальных приоритетов:** Клиенты теперь получают разные приоритеты avoidance при навигации, что позволяет им более естественно уступать друг другу дорогу.

**Компоненты системы:**

### 1. CustomerLocomotion - Методы управления приоритетом
- `SetAvoidancePriority(int priority)` - устанавливает приоритет (0-99, меньше = выше приоритет)
- `GetAvoidancePriority()` - возвращает текущий приоритет

### 2. CustomerSpawnerService - Конфигурация
**Новые настройки в инспекторе:**
- `_minAvoidancePriority = 30` - минимальный приоритет (высший)
- `_maxAvoidancePriority = 70` - максимальный приоритет (низший)  
- `_useUniqueAvoidancePriority = false` - режим генерации приоритетов

**Логика генерации:**
- **Случайный режим** (`_useUniqueAvoidancePriority = false`): каждый клиент получает случайный приоритет в диапазоне
- **Уникальный режим** (`_useUniqueAvoidancePriority = true`): каждый клиент получает последовательный уникальный приоритет

### 3. Система сохранения/загрузки
**Расширена `CustomerSaveData`:**
- Добавлено поле `AvoidancePriority` для сохранения приоритета клиента

**Обновлен `CustomerManagerService`:**
- `GetAvoidancePriority()` - получает приоритет для сохранения
- Восстановление приоритета при загрузке из сейва

**Принцип работы приоритетов:**
- **Меньшее число = выше приоритет** (NavMeshAgent стандарт)
- Клиент с приоритетом 30 будет проходить сквозь клиента с приоритетом 60
- Клиент с приоритетом 60 будет уступать дорогу клиенту с приоритетом 30

## ✅ КРИТИЧЕСКИЙ БАГФИКС: Исправлено сохранение состояния клиентов при выходе из магазина

**Найдена и исправлена критическая проблема:** Клиенты, которые шли к ExitPoint при сохранении игры, после загрузки начинали идти к кассе или полкам вместо продолжения выхода.

**Дополнительный багфикс (2024-12-03):** Обнаружена вторая критическая проблема - **отсутствие инициализации состояния** после восстановления клиентов:

**ФИНАЛЬНЫЙ БАГФИКС (2024-12-03):** Найдена настоящая корневая причина - **метод `Initialize` принудительно переводил всех клиентов в состояние `Shopping`:**

**Корневая проблема:** Последовательность восстановления была неправильной:
1. `customerController.Initialize(customerData)` ← **ПРИНУДИТЕЛЬНО** устанавливает `CustomerState.Shopping`
2. `RestoreControllerState(saveData)` ← пытается восстановить правильное состояние, но уже поздно

**Финальное решение:**
1. **Создан метод `InitializeRestored(customerData)`** - инициализирует клиента БЕЗ смены состояния
2. **Обновлен `CustomerManagerService.RestoreCustomer()`** - использует `InitializeRestored` вместо `Initialize`
3. **Сохранен метод `InitializeRestoredState()`** - правильно инициализирует поведение состояния после восстановления данных

**Правильная последовательность теперь:**
1. `customerController.InitializeRestored(customerData)` ← инициализация БЕЗ смены состояния
2. `RestoreControllerState(saveData)` ← восстановление всех данных И состояния
3. `InitializeRestoredState()` ← инициализация поведения для восстановленного состояния

**Причина:** **Отсутствие инициализации состояния** - восстановленные данные клиента были корректными, но состояние не было проинициализировано:

1. `_personalExitPosition` (персональная позиция выхода) не сохранялась в `CustomerSaveData`
2. `_exitPoint` не восстанавливалась в методе `RestoreState` 
3. `StartLeaving()` всегда создавал новую позицию, игнорируя восстановленную

**Решение:** Добавлена полная поддержка сохранения/восстановления состояния выхода:

### 1. Расширена структура сохранения `CustomerSaveData`:
```csharp
// Данные для состояния выхода
public Vector3 PersonalExitPosition; // Персональная позиция выхода
public bool HasPersonalExitPosition; // Флаг наличия персональной позиции выхода
```

### 2. Добавлены методы получения данных в `CustomerController`:
```csharp
public Vector3 GetPersonalExitPosition() => _personalExitPosition;
public bool HasPersonalExitPosition() => _personalExitPosition != Vector3.zero;
```

### 3. Обновлен сбор данных в `CustomerManagerService`:
```csharp
// Данные для состояния выхода
PersonalExitPosition = GetPersonalExitPosition(controller),
HasPersonalExitPosition = GetHasPersonalExitPosition(controller)
```

### 4. Исправлен метод `RestoreState` в `CustomerController`:
```csharp
// Восстанавливаем точку выхода из сервиса
if (_storePointsService != null)
{
    _exitPoint = _storePointsService.ExitPoint;
}

// Восстанавливаем персональную позицию выхода (если была сохранена)
if (saveData.HasPersonalExitPosition)
{
    _personalExitPosition = saveData.PersonalExitPosition;
}
```

### 5. Улучшен метод `StartLeaving`:
```csharp
// Если у нас нет сохраненной персональной позиции выхода, создаем новую
if (_personalExitPosition == Vector3.zero)
{
    // Создаем новую позицию
    Vector2 randomOffset = UnityEngine.Random.insideUnitCircle * _exitRadius;
    _personalExitPosition = _exitPoint.position + new Vector3(randomOffset.x, 0, randomOffset.y);
}
else
{
    // Используем восстановленную позицию
    Debug.Log($"Using restored personal exit position {_personalExitPosition}");
}
```

**Результат:** 
- ✅ Клиенты в состоянии `Leaving` корректно восстанавливают свою персональную позицию выхода
- ✅ Точка выхода (`_exitPoint`) правильно инициализируется из `IStorePointsService`
- ✅ `UpdateLeaving()` теперь работает с правильными данными
- ✅ Предотвращено переключение клиентов в другие состояния после загрузки
- ✅ Сохранена обратная совместимость для новых клиентов
- ✅ Детальное логирование для отладки

## ✅ КРИТИЧЕСКИЙ БАГФИКС: ESC перестает работать после быстрого сохранения

**Найдена и исправлена критическая проблема:** При быстром сохранении переставал вызываться меню на ESC.

**Причина:** **Двойной вызов `PopScreen()`** - конфликт между `GameMenuHandler` и `SaveGameMenuHandler`:

1. `GameMenuHandler.OnQuickSaveClicked()` вызывает быстрое сохранение
2. `SaveGameService.SaveGame()` при успешном сохранении генерирует событие `OnSaveCompleted` 
3. **`SaveGameMenuHandler.OnSaveCompleted()` автоматически вызывает `PopScreen()`** (даже когда `SaveGameMenuHandler` не активен!)
4. Затем `GameMenuHandler.OnQuickSaveClicked()` **снова** вызывает `PopScreen()`
5. **Двойной `PopScreen()` нарушает состояние стека экранов** и ломает навигацию ESC

**Решение:** Исправлен `SaveGameMenuHandler.OnSaveCompleted()` - теперь закрывает экран **ТОЛЬКО** если `SaveGameMenuHandler` является текущим активным экраном:

```csharp
if (_uiNavigationService != null && _uiNavigationService.CurrentScreen == UIScreenType.SaveGameMenu)
{
    _uiNavigationService.PopScreen(); // Закрываем только если SaveGameMenu активен
}
```

**Результат:** 
- ✅ ESC работает корректно после быстрого сохранения
- ✅ Устранен конфликт между разными обработчиками событий сохранения
- ✅ Сохранено правильное поведение для обычного сохранения через SaveGameMenu

## Current Focus
Реализована **новая UI Navigation архитектура** - создана единая система управления экранами, навигации и обработки ESC. Решены проблемы с паузой и навигацией в интерфейсе.

**✅ УДАЛЕНА УСТАРЕВШАЯ СИСТЕМА MENUNAVIGATIONSERVICE!** Полностью переход на новую архитектуру `UINavigationService` для всех сцен и экранов.

**✅ ДОБАВЛЕНА СИСТЕМА ТОЧЕК ПОДХОДА К ПОЛКАМ:** Реализована возможность настройки точек подхода для покупателей к полкам для более реалистичного поведения.

Работа над **Этапом 11: Экономика и UI** - добавление отображения денег, уведомлений и системы статистики.

**✅ РЕШЕНА ПРОБЛЕМА ESC В ИГРЕ:** Пользователь нажимал ESC, курсор появлялся (input mode переключался), но игровое меню не отображалось. Проблема была в UXML/USS структуре, а не в коде.

**✅ РЕШЕНА ПРОБЛЕМА SaveGameMenu/LoadGameMenu:** Исправлена архитектура - теперь `SaveGameMenuHandler` это один экран `SaveGameMenu`, который работает в разных режимах (SaveMode/LoadMode/FullMode), вместо двух отдельных типов экранов.

**✅ ИСПРАВЛЕНО НАРУШЕНИЕ ПРАВИЛ BInject:** Убраны все использования `FindObjectOfType<>()` и заменены на правильное dependency injection через интерфейс `ISaveGameMenuHandler`.

**✅ РЕШЕНА ПРОБЛЕМА с выключенным SaveGameMenuHandler:** GameObject теперь остается активным, а видимость контролируется через `Show()/Hide()` методы BaseUIScreen.

**✅ ИСПРАВЛЕНА ПРОБЛЕМА АВТОПОКАЗА SaveGameMenuHandler:** Экран больше не показывается автоматически при запуске игры - добавлено принудительное скрытие в `OnEnable()`.

**✅ ИСПРАВЛЕНЫ ПРОБЛЕМЫ ЗАГРУЗКИ СОХРАНЕНИЙ:** Решены проблемы с загрузкой из главного меню и работой ESC после загрузки в игре.

**✅ СОЗДАНА СИСТЕМА СОХРАНЕНИЯ/ВОССТАНОВЛЕНИЯ КОРОБОК:** Реализован `BoxManagerService` для управления коробками на земле с полной интеграцией в систему сохранения.

## Box Save/Load System Implementation:

### ✅ Система сохранения коробок полностью реализована!

**Проблема:** Коробки на земле не сохранялись и не восстанавливались при загрузке игры.

**Причина:** В `SaveGameService` были TODO комментарии вместо реальной реализации сбора и восстановления данных коробок.

**Решение:**
1. **Создан `IBoxManagerService` интерфейс** с методами:
   - `RegisterBox()` / `UnregisterBox()` - регистрация коробок в сцене
   - `GetBoxesSaveData()` - сбор данных для сохранения
   - `RestoreBoxes()` - восстановление коробок из сохранения
   - `CreateBox()` - создание коробки с указанными данными
   - `ClearAllBoxes()` - очистка всех коробок

2. **Реализован `BoxManagerService` MonoBehaviour** с функциональностью:
   - Ведет список всех активных коробок на сцене
   - Собирает данные коробок в формате `BoxSaveData`
   - Восстанавливает коробки через `ProductCatalogService`
   - Автоматически создает коробки с правильной инициализацией

3. **Обновлен `BoxController`** для интеграции:
   - Автоматическая регистрация в `BoxManagerService` при `Start()`
   - Автоматическая разрегистрация при `OnDestroy()`
   - Добавлен `IBoxManagerService` в dependency injection

4. **Интегрирован в `SaveGameService`**:
   - `CollectStoreData()` теперь использует `_boxManagerService.GetBoxesSaveData()`
   - `ApplySaveData()` восстанавливает коробки через `_boxManagerService.RestoreBoxes()`
   - Добавлено детальное логирование процесса

5. **Обновлены сервисы для использования `BoxManagerService`**:
   - `DeliveryService` создает коробки через `_boxManagerService.CreateBox()`
   - `PlayerBoxController` выбрасывает коробки через `_boxManagerService.CreateBox()`
   - Убраны прямые ссылки на box prefab из компонентов

6. **Зарегистрирован в `GameContextInitiator`**:
   - Добавлена ссылка на `BoxManagerService` instance
   - Регистрация как `IBoxManagerService` в game context
   - Правильная настройка dependency injection

**Ключевые улучшения:**
- ✅ Полное отслеживание всех коробок на сцене
- ✅ Автоматическая регистрация/разрегистрация коробок
- ✅ Поддержка пустых коробок (ProductInBox == null)
- ✅ Правильное восстановление через ProductCatalogService
- ✅ Централизованное управление созданием коробок
- ✅ Интеграция с физикой при выбрасывании
- ✅ Детальное логирование для отладки

**Результат:**
- ✅ Коробки на земле теперь сохраняются в файл сохранения
- ✅ При загрузке игры все коробки восстанавливаются на своих позициях
- ✅ Сохраняется тип товара, количество и позиция коробки
- ✅ Поддержка как полных, так и пустых коробок
- ✅ Полная интеграция с доставкой и выбрасыванием коробок

## Clean Architecture Achieved:

### ✅ Единая система навигации UI!
**Удалена устаревшая система:**
- Удален `MenuNavigationService.cs`
- Удален `IMenuNavigationService.cs`
- Удален `MenuUIHandler.cs` (заменен на `MainMenuScreen`)

**Полный переход на новую архитектуру:**
- Все UI экраны используют `UINavigationService`
- Единая система стека экранов
- Корректная обработка ESC на всех экранах
- Правильное управление паузой и input modes
- Централизованная регистрация экранов

**Обновлены контексты:**
1. **CommonContext** - больше не регистрирует устаревший `MenuNavigationService`
2. **MenuContext** - использует `MainMenuScreen` вместо `MenuUIHandler`
3. **GameContext** - убран импорт удаленного пространства имен

**Архитектурные преимущества:**
- ✅ Нет дублирования функциональности
- ✅ Единый стандарт для всех экранов
- ✅ Правильное dependency injection
- ✅ Простое добавление новых экранов
- ✅ Централизованное управление состоянием UI

## Problem Analysis & Solution:

### ✅ Проблема ESC решена полностью!
**Причина:** UXML структура имела `GameMenuOverlay` с `style="display: none;"` inline, который не контролировался базовым методом `Show()`.

**Решение:**
1. **Обновлен `GameMenuHandler`** - переопределены методы `Show()` и `Hide()`
2. **Добавлен специфичный контроль** элемента `GameMenuOverlay`
3. **Перенесено управление display** из inline UXML стиля в USS класс
4. **Добавлен поиск элементов** и обработка ошибок

**Ключевые изменения:**
- `GameMenuHandler` теперь находит и контролирует элемент `GameMenuOverlay` напрямую
- Убран inline `style="display: none;"` из UXML 
- Добавлен `display: none;` в USS класс для начального состояния
- Добавлено детальное логирование процесса показа/скрытия

**Результат:** ESC теперь корректно открывает/закрывает игровое меню!

### ✅ Проблема SaveGameMenu архитектуры решена!
**Причина:** Неправильная архитектура - один экран `SaveGameMenuHandler` пытался быть двумя типами экранов (`SaveGameMenu` и `LoadGameMenu`).

**Решение:**
1. **Один экран, один тип** - `SaveGameMenuHandler` всегда `UIScreenType.SaveGameMenu`
2. **Режимы работы** - через `SaveGameMenuMode` (SaveMode/LoadMode/FullMode)
3. **Убран LoadGameMenu** из `UIScreenType` enum
4. **Обновлены все ссылки** в GameMenuHandler, MainMenuScreen, UINavigationService
5. **SaveGameMenuHandler в CommonContext** - не нужно создавать отдельно в GameScene

**Ключевые изменения:**
- Убран `UIScreenType.LoadGameMenu` из enum
- `SaveGameMenuHandler.SetMenuMode()` не меняет ScreenType, только режим работы UI
- `GameMenuHandler` и `MainMenuScreen` используют `SaveGameMenu` с разными режимами
- Все navigation logic обновлен для одного типа экрана

**Результат:** Корректная архитектура - один экран, разные режимы работы!

### ✅ Нарушение BInject правил исправлено!
**Проблема:** Использование запрещенного `FindObjectOfType<SaveGameMenuHandler>()` в `GameMenuHandler` и `MainMenuScreen`.

**Решение:**
1. **Создан интерфейс** `ISaveGameMenuHandler` с методом `SetMenuMode()`
2. **SaveGameMenuHandler** реализует интерфейс `ISaveGameMenuHandler`
3. **Зарегистрирован в CommonContext** как `ISaveGameMenuHandler`
4. **Dependency injection** в `GameMenuHandler` и `MainMenuScreen`
5. **Убран FindObjectOfType** - теперь используется `[Inject] public ISaveGameMenuHandler _saveGameMenuHandler`

**Ключевые изменения:**
- `SaveGameMenuHandler : BaseUIScreen, ISaveGameMenuHandler`
- Регистрация в `CommonContextInitiator`: `_commonContext.RegisterDependency<ISaveGameMenuHandler>(_saveGameMenuHandler)`
- Внедрение зависимости: `[Inject] public ISaveGameMenuHandler _saveGameMenuHandler`
- Использование: `_saveGameMenuHandler.SetMenuMode(SaveGameMenuMode.SaveMode, true)`

**Результат:** Полное соблюдение правил BInject - только dependency injection, никаких поисков объектов!

### ✅ Проблема с выключенным GameObject решена!
**Проблема:** `SaveGameMenuHandler` GameObject был выключен программно, из-за чего он не регистрировался в `UINavigationService` (так как `OnEnable()` не вызывался).

**Решение:**
1. **GameObject остается активным** - `CommonContextInitiator` принудительно активирует SaveGameMenuHandler
2. **Использование Show()/Hide()** вместо `SetActive()`
3. **Начальное скрытие** - `SaveGameMenuHandler.Hide()` вызывается при инициализации
4. **Совместимость архитектур** - старая и новая системы работают вместе

**Ключевые изменения:**
- `CommonContextInitiator`: принудительная активация GameObject + начальный `Hide()`
- Использование `Show()/Hide()` методов для управления видимостью
- Регистрация в `UINavigationService` теперь работает корректно

**Результат:** SaveGameMenuHandler регистрируется в UINavigationService и доступен для навигации!

### ✅ Проблема автопоказа SaveGameMenuHandler решена!
**Проблема:** При запуске игры `SaveGameMenuHandler` автоматически отображался, хотя должен быть скрыт по умолчанию.

**Причина:** Раннее выполнение `Hide()` в `CommonContextInitiator.Awake()` когда `_rootElement` еще не инициализирован.

**Решение:**
1. **Перенос логики скрытия** в `SaveGameMenuHandler.OnEnable()` после инициализации `_rootElement`
2. **Принудительное скрытие** при каждом OnEnable через `display = DisplayStyle.None`
3. **Убран ранний вызов** `Hide()` из `CommonContextInitiator`

**Ключевые изменения:**
- Добавлен `SaveGameMenuHandler.OnEnable()` с принудительным скрытием
- Удален ранний `Hide()` вызов из `CommonContextInitiator.Awake()`
- Экран теперь скрывается автоматически при регистрации

**Результат:** SaveGameMenuHandler скрыт по умолчанию и показывается только при явном вызове `Show()`!

### ✅ Проблемы загрузки сохранений решены!

#### **Проблема 1: Загрузка из главного меню не восстанавливала состояние**
**Причина:** Загрузка происходила в главном меню, где нет игровых объектов для восстановления.

**Решение:**
1. **Разделена логика загрузки** по контекстам (главное меню vs игра)
2. **Из главного меню** - используется `SetSelectedSaveFile()` + переход в игровую сцену
3. **В игре** - применяется загрузка сразу через `LoadGame()`
4. **Автоматическая загрузка** в игровой сцене через `LoadGameInGameScene()`

**Ключевые изменения:**
- `SaveGameMenuHandler.OnLoadClicked()` - разная логика для разных контекстов
- Убрана дублирующая логика переключения сцены в `OnLoadCompleted()`
- Использование правильного механизма отложенной загрузки

#### **Проблема 2: ESC переставал работать после загрузки в игре**
**Причина:** Конфликт между `PopAllScreens()` и принудительной установкой `InputMode.Game` в `SaveGameService`.

**Решение:**
1. **Убрана принудительная установка** input mode в `SaveGameService.ApplySaveData()`
2. **UINavigationService управляет** input mode через `PopAllScreens()`
3. **Исправлен `PopAllScreens()`** - теперь возвращается к `GameHUD` вместо полной очистки
4. **Правильное восстановление** игрового состояния

**Ключевые изменения:**
- `SaveGameService.ApplySaveData()` - убрана установка input mode
- `UINavigationService.PopAllScreens()` - возврат к GameHUD в игровом контексте
- Правильная последовательность: загрузка → PopAllScreens → показ GameHUD → установка Game input mode

**Результат:**
- ✅ Загрузка из главного меню корректно восстанавливает состояние в игровой сцене
- ✅ ESC работает после загрузки в игре
- ✅ Правильное управление input modes и экранами
- ✅ Корректный возврат к GameHUD после загрузки

## Recent Major Changes:

### ✅ Создание системы сохранения коробок:
- **Создан BoxManagerService:**
  - `IBoxManagerService` интерфейс для управления коробками
  - `BoxManagerService` MonoBehaviour реализация
  - Автоматическая регистрация/разрегистрация коробок
  - Методы для сбора и восстановления данных сохранения
- **Интеграция в систему сохранения:**
  - `SaveGameService` использует `BoxManagerService` для коробок
  - `BoxController` автоматически регистрируется в сервисе
  - `DeliveryService` и `PlayerBoxController` используют централизованное создание
- **Результат:** Полная поддержка сохранения/загрузки коробок на земле

### ✅ Удаление устаревшей системы MenuNavigationService:
- **Удалены файлы:**
  - `MenuNavigationService.cs`
  - `IMenuNavigationService.cs`
  - `MenuUIHandler.cs`
- **Обновлены контексты:**
  - `CommonContextInitiator` - убрана регистрация MenuNavigationService
  - `MenuContextInitiator` - переход на MainMenuScreen + UINavigationService
  - `GameContextInitiator` - убран импорт удаленного namespace
- **Результат:** Единая архитектура UI без дублирования функциональности

### Новая UI Navigation System (Completed):

1. **Создана архитектура экранов и навигации:**
   - `IUINavigationService` и `UINavigationService` - центральное управление UI
   - `IUIScreen` интерфейс для всех экранов
   - `BaseUIScreen` базовый класс с общей функциональностью
   - Поддержка стека экранов с proper back navigation
   - Единое управление паузой и input modes

2. **Решена проблема с ESC навигацией:**
   - Добавлено действие "Cancel" в Input Actions (ESC key)
   - `UIInputHandler` - центральная обработка UI input'a
   - ESC теперь работает как универсальная кнопка "назад"
   - Корректная обработка ESC на любом экране

3. **Исправлена система паузы:**
   - Пауза сохраняется при навигации между экранами
   - ESC в игровом меню не снимает паузу неожиданно
   - Пауза снимается только при возврате к игровому HUD
   - Единое управление `Time.timeScale` через UINavigationService

4. **Архитектура экранов:**
   - `GameHUDScreen` - не паузит игру, не блокирует input
   - `GameMenuHandler` (как `BaseUIScreen`) - паузит игру, блокирует input
   - `MainMenuScreen` - для главного меню
   - `SaveGameMenuHandler` - универсальный экран сохранения/загрузки
   - Каждый экран может определить свое поведение (пауза, блокировка input, возможность назад)

5. **Централизованное управление:**
   - `UINavigationService` зарегистрирован в Application контексте
   - Все экраны автоматически регистрируются при OnEnable
   - Поддержка контекстов Main Menu и Game
   - События изменения экранов и состояния паузы

6. **Обновлены существующие компоненты:**
   - `GameMenuHandler` переделан на `BaseUIScreen`
   - Убрана старая логика с Update() и Input.GetKeyDown(KeyCode.Escape)
   - Все UI компоненты теперь используют новую навигационную систему

7. **Исправлены нарушения BInject:**
   - Все поля с `[Inject]` в MonoBehaviour теперь `public`
   - MainMenuScreen, BaseUIScreen, UIInputHandler исправлены
   - Соблюдение правил dependency injection

## Current Problem Analysis:

### Проблема: ESC не показывает игровое меню
**Симптомы:**
- ESC нажимается → курсор появляется (Input Mode UI активируется)
- GameMenu не отображается на экране
- UIInputHandler работает (получает события)

**Добавленная диагностика:**
1. **UINavigationService.PushScreen()** - логирует регистрацию экранов и процесс показа
2. **BaseUIScreen.Show()** - логирует состояние GameObject и rootElement
3. **UINavigationService.RegisterScreen()** - отслеживает регистрацию всех экранов

**Возможные причины:**
1. `GameMenuHandler` не зарегистрирован в UINavigationService
2. `GameMenuHandler.Show()` вызывается, но UI не отображается
3. UIDocument не настроен или не активен
4. Проблемы с сортировкой UI элементов
5. GameObject с GameMenuHandler неактивен

**План отладки:**
1. Проверить логи Unity Console при нажатии ESC
2. Убедиться, что GameMenuHandler зарегистрирован
3. Проверить состояние UIDocument и root элемента
4. Проверить настройки в Unity Editor

## Recent Major Changes:

### ✅ Исправление ESC навигации:
- **Исправлена структура UXML/USS** для правильного контроля видимости
- **Переопределены Show()/Hide()** в GameMenuHandler для контроля GameMenuOverlay
- **Добавлена детальная диагностика** для отслеживания процесса показа меню

### Новая UI Navigation System:

1. **Создана архитектура экранов и навигации:**
   - `IUINavigationService` и `UINavigationService` - центральное управление UI
   - `IUIScreen` интерфейс для всех экранов
   - `BaseUIScreen` базовый класс с общей функциональностью
   - Поддержка стека экранов с proper back navigation
   - Единое управление паузой и input modes

2. **Решена проблема с ESC навигацией:**
   - Добавлено действие "Cancel" в Input Actions (ESC key)
   - `UIInputHandler` - центральная обработка UI input'a
   - ESC теперь работает как универсальная кнопка "назад"
   - Корректная обработка ESC на любом экране

3. **Исправлена система паузы:**
   - Пауза сохраняется при навигации между экранами
   - ESC в игровом меню не снимает паузу неожиданно
   - Пауза снимается только при возврате к игровому HUD
   - Единое управление `Time.timeScale` через UINavigationService

4. **Архитектура экранов:**
   - `GameHUDScreen` - не паузит игру, не блокирует input
   - `GameMenuHandler` (как `BaseUIScreen`) - паузит игру, блокирует input
   - `MainMenuScreen` - для главного меню
   - Каждый экран может определить свое поведение (пауза, блокировка input, возможность назад)

5. **Централизованное управление:**
   - `UINavigationService` зарегистрирован в Application контексте
   - Все экраны автоматически регистрируются при OnEnable
   - Поддержка контекстов Main Menu и Game
   - События изменения экранов и состояния паузы

6. **Обновлены существующие компоненты:**
   - `GameMenuHandler` переделан на `BaseUIScreen`
   - Убрана старая логика с Update() и Input.GetKeyDown(KeyCode.Escape)
   - Все UI компоненты теперь используют новую навигационную систему

7. **Исправлены нарушения BInject:**
   - Все поля с `[Inject]` в MonoBehaviour теперь `public`
   - MainMenuScreen, BaseUIScreen, UIInputHandler исправлены
   - Соблюдение правил dependency injection

### Упрощение системы размещения объектов:

1. **Удалена кнопка "Строить" и UI панель:**
   - Убрана кнопка `OpenPlacementMenuButton` из GameHUD.uxml
   - Удалена панель `PlacementPanel` для выбора объектов
   - Убран весь связанный код из `GameUIHandler`
   - Удалена клавиша B для открытия меню размещения

2. **Оставлено размещение из коробки:**
   - `PlacementService` сохранен для размещения из руки
   - `PlayerHandPlacementController` работает через клавишу размещения из руки
   - `PlacementController` управляет процессом размещения
   - Система сохранения/загрузки размещенных объектов работает

3. **Упрощен GameUIHandler:**
   - Убраны зависимости на `IPlacementService`, `IProductCatalogService`, `IInputModeService`
   - Оставлены только функции: отображение денег, информация о коробке в руке, уведомления
   - Упрощено Update() - только обновление информации о коробке

4. **Переработан GameHUD.uxml:**
   - Убрана сложная панель размещения
   - Упрощен layout - только HUD элементы
   - Перемещен контейнер уведомлений в правый верхний угол
   - Перемещен индикатор денег в левый верхний угол

### Система очередей покупателей (Customer Queue System):

1. **Новое состояние `JoiningQueue`:**
   - Добавлено промежуточное состояние между `GoingToCashier` и `WaitingInQueue`
   - Покупатели сначала идут к концу очереди, затем выравниваются
   - Предотвращает подход к очереди сбоку

2. **Резервирование мест в очереди:**
   - Создан механизм резервирования (`ReserveApproachingSpot`/`CancelApproachingSpot`)
   - Список `_customersApproaching` отслеживает покупателей, идущих к кассе
   - Решена проблема одновременного движения к одной точке

3. **Улучшенная навигация в очереди:**
   - Покупатели выравниваются вдоль линии очереди
   - Проверка бокового смещения и корректировка движения
   - Плавное перестроение без столкновений

4. **Исправление логики обслуживания:**
   - Использование `Peek()` вместо `Dequeue()` при начале обслуживания
   - Покупатель остается в очереди на позиции 0 во время оплаты
   - Удаление из очереди только после завершения обслуживания

### Исправления анимаций покупателей:

1. **Контроль воспроизведения анимаций:**
   - Добавлены флаги `_pickupAnimationPlayed`, `_payAnimationPlayed`
   - Сброс триггеров перед установкой новых (`ResetTrigger`)
   - Метод `ResetAllActionTriggers()` при смене состояний

2. **Ожидание завершения анимаций:**
   - Методы `IsPickupAnimationComplete()`, `IsPayAnimationComplete()`
   - Проверка `normalizedTime` анимации (95% завершения)
   - Таймаут защиты от зависания (5 секунд)

3. **Синхронизация с игровой логикой:**
   - Взятие товара происходит после завершения анимации pickup
   - Переход из состояния Paying только после анимации оплаты
   - Корректное повторение анимации для каждого взятого предмета

### Архитектурные улучшения:

1. **Сервисы вместо поиска по тегам:**
   - `ICashDeskService` для управления кассами
   - `IStorePointsService` для точек входа/выхода
   - `IInteractionService` для избежания дублирования Raycast

2. **Улучшенное обновление позиций:**
   - Метод `UpdateQueuePosition` теперь активирует движение при изменении
   - Автоматическое движение очереди вперед после ухода клиента

### Этап 11: Экономика и UI (Завершен):

1. **Отображение бюджета игрока:**
   - ✅ Добавлена панель денег в правый верхний угол HUD (GameHUD.uxml)
   - ✅ `GameUIHandler` подписывается на изменения денег через `IPlayerDataService.OnMoneyChanged`
   - ✅ Добавлены методы `GetMoney()` и событие `OnMoneyChanged` в `PlayerDataService`
   - ✅ Деньги отображаются в формате "$XXX.XX"
   - ✅ Обновление в реальном времени при любых транзакциях

2. **Система уведомлений:**
   - ✅ Создан контейнер для уведомлений в левом нижнем углу
   - ✅ Добавлен метод `ShowNotification()` в `GameUIHandler`
   - ✅ Создан `INotificationService`/`NotificationService` для централизованного управления
   - ✅ Поддержка типов уведомлений: Info, Success, Warning, Error
   - ✅ Автоматическое удаление уведомлений через заданное время
   - ✅ Интегрированы уведомления:
     - Низкий запас товаров на полках
     - Доставка товаров
     - Успешный/неудачный заказ
     - Недостаток денег

3. **Система статистики:**
   - ✅ Создан `IStatsService`/`StatsService` для сбора игровой статистики
   - ✅ Отслеживание: доходов, расходов, обслуженных покупателей, проданных товаров
   - ✅ Методы записи событий: `RecordSale()`, `RecordPurchase()`, `RecordCustomerServed()`
   - ✅ Расчет среднего чека и определение самого популярного товара
   - ✅ Зарегистрирован в ApplicationContext

4. **UI статистики в компьютере:**
   - ✅ Добавлена полноценная вкладка "Статистика" в ComputerScreen.uxml
   - ✅ Три секции: Финансы, Покупатели, Товары
   - ✅ Визуально оформленные блоки с цветовой кодировкой
   - ✅ Подключены реальные данные из `IStatsService`

5. **Интеграция статистики:**
   - ✅ `CashDeskController` записывает продажи и обслуженных клиентов
   - ✅ `ComputerUIHandler` записывает расходы на закупки
   - ✅ Все транзакции автоматически отражаются в статистике

### Проблемы с компиляцией:
- Unity еще не обновил assembly references для новых файлов в Supermarket.Services.UI
- Временно закомментированы ссылки на `INotificationService` и `IStatsService`
- После обновления Unity нужно будет раскомментировать

## Текущее состояние системы:

### Полностью работающие механики:
- ✅ Заказ товаров через компьютер
- ✅ Доставка в коробках
- ✅ Подбор и открытие/закрытие коробок
- ✅ Размещение товаров на полках (ЛКМ/ПКМ)
- ✅ ИИ покупателей с навигацией
- ✅ Система очередей без коллизий
- ✅ Работа кассиром (нажатие E)
- ✅ Анимации действий покупателей
- ✅ Экономика (деньги игрока)
- ✅ Система сохранения/загрузки игры
- ✅ Сохранение/восстановление коробок на земле

### Требуется настройка в Unity:
- NavMesh для навигации покупателей
- Префабы с правильными компонентами
- Точки спавна и выхода
- Модели и анимации покупателей
- Настройка BoxManagerService в GameScene с ссылкой на box prefab

## Ближайшие задачи:

### Готовые для разработки этапы:

**Этап 17: Визуальные улучшения взаимодействия с коробками** (следующий приоритет)
- Визуализация коробки в руках игрока (3D модель)
- Анимации открытия/закрытия крышки коробки
- Отображение 3D моделей товаров внутри открытой коробки
- Анимация перемещения товаров из коробки на полку

**Этап 18: Улучшение системы касс**
- Режим работы за кассой с фиксированной камерой
- Визуальная кассовая лента для товаров покупателей
- Механика сканирования товаров с курсором
- Детальное UI кассы с отсканированными товарами

**Этап 19: Дополнительные улучшения**
- Звуковое оформление (шаги, сканер, фоновая музыка)
- Визуальные эффекты и улучшенное освещение
- Оптимизация производительности (LOD, пулинг объектов)

### Требуется настройка в Unity Editor:
- Создание префабов многоуровневых полок для Этапа 13
- NavMesh для навигации покупателей
- Настройка BoxManagerService в GameScene с ссылкой на box prefab
- Точки спавна и выхода для покупателей
- Модели и анимации покупателей

## Архитектурные преимущества системы доставки (Stage 16):

✅ **Реалистичность** - заказы доставляются не мгновенно, а через заданное время
✅ **Планирование** - игрок может отслеживать и планировать множественные заказы
✅ **Интерактивность** - возможность отменить заказ до доставки
✅ **Обратная связь** - уведомления на всех этапах заказа
✅ **Сохранение состояния** - активные заказы не теряются при сохранении/загрузке
✅ **Производительность** - оптимизированное обновление UI только когда нужно
✅ **Расширяемость** - легко добавить новые типы уведомлений или логику доставки

## Previously (Этап 9 - завершен):
Начата работа над **Этапом 9: Покупатели** из `Plan.md`. Реализована базовая система спавна и ИИ покупателей.

## Recent Changes:

- **Этап 9: Покупатели (В процессе):**
    - **Создана структура данных покупателей:**
        - `CustomerData.cs` - основные данные покупателя (имя, деньги, скорость, терпение).
        - `ShoppingItem` - элемент списка покупок с отслеживанием прогресса.
        - `CustomerState` enum - состояния для State Machine (Entering, Shopping, GoingToShelf, etc.).
    
    - **Реализован сервис спавна покупателей:**
        - `ICustomerSpawnerService.cs` - интерфейс с методами управления спавном.
        - `CustomerSpawnerService.cs` - MonoBehaviour сервис, который:
            - Спавнит покупателей с заданным интервалом.
            - Генерирует случайные данные покупателей (имя, деньги, список покупок).
            - Фильтрует товары только с флагом `CanBePlacedOnShelf`.
            - Отслеживает активных покупателей.
        - Зарегистрирован в `GameContextInitiator.cs`.
    
    - **Создан базовый ИИ покупателя:**
        - `CustomerController.cs` - основной компонент управления покупателем:
            - Использует State Machine паттерн для управления поведением.
            - Требует `NavMeshAgent` для навигации.
            - Ищет полки с нужными товарами.
            - Берет товары с полок через `ShelfController.CustomerTakeItem()`.
            - Идет к кассе после сбора товаров (заглушка, т.к. кассы еще не реализованы).
            - Уходит из магазина через точку выхода.
    
    - **Обновлен ShelfController:**
        - Добавлен публичный метод `GetCurrentItemCount()` для проверки наличия товаров.
        - Добавлен метод `CustomerTakeItem()` для взятия товаров покупателями.
    
    - **Интеграция в GameManager:**
        - `GameManager.cs` теперь получает `ICustomerSpawnerService`.
        - Автоматически запускает спавн покупателей через 3 секунды после старта.
        - Останавливает спавн при уничтожении.

## Ближайшие Задачи (Требуют действий в Unity Editor)

1. **Настройка сцены для покупателей:**
    - **Создать NavMesh** в GameScene (Window > AI > Navigation, выделить пол, отметить как Navigation Static, нажать Bake).
    - **Создать префаб покупателя:**
        - GameObject типа Capsule или простой гуманоид.
        - Добавить компоненты: `NavMeshAgent`, `CustomerController`, `Injector` (настроить на контекст "Game").
        - Сохранить как префаб в `Assets/Prefabs/`.
    - **Создать точки в сцене:**
        - GameObject с тегом "Exit" - точка выхода из магазина.
        - GameObject с тегом "Cashier" - точка кассы (пока заглушка).
    - **Создать GameObject для CustomerSpawnerService:**
        - Добавить компонент `CustomerSpawnerService`.
        - Настроить Customer Prefab и Spawn Point.
        - Добавить компонент `Injector` (контекст "Game").
        - Назначить этот GameObject в `GameContextInitiator` в поле `_customerSpawnerServiceInstance`.

2. **Настройка BoxManagerService:**
    - **Создать GameObject для BoxManagerService:**
        - Добавить компонент `BoxManagerService`.
        - Настроить Box Prefab в инспекторе.
        - Добавить компонент `Injector` (контекст "Game").
        - Назначить этот GameObject в `GameContextInitiator` в поле `_boxManagerServiceInstance`.

3. **Дальнейшее развитие системы покупателей:**
    - Визуальная обратная связь (анимации, индикаторы над головой).
    - Более сложная логика выбора товаров.
    - Система очередей у касс.
    - Различные типы покупателей с разным поведением.

4. **Следующий этап - Кассы (Этап 10):**
    - Создание системы касс для обслуживания покупателей.
    - Взаимодействие игрока с кассой.
    - Процесс оплаты и обновление денег игрока.

## Открытые Вопросы и Решения для Обсуждения

- **Баланс спавна:** Какая должна быть частота появления покупателей и их количество?
- **Сложность ИИ:** Нужны ли более сложные паттерны поведения (нетерпеливые покупатели, VIP-клиенты)?
- **Визуализация:** Какой стиль для моделей покупателей предпочтителен?

## Memory Bank & .cursorrules
- Файлы Memory Bank обновлены для отражения прогресса по системе покупателей.
- План обновлен с отметками о выполненных задачах.

### Этап 15: Улучшение интерфейса компьютера (Завершен):

1. **Система категорий и подкатегорий:**
   - ✅ Основные вкладки: Магазин, Управление Ценами, Лицензии, Статистика
   - ✅ Подвкладки в магазине: Товары, Мебель
   - ✅ Подкатегории товаров: Напитки, Снеки, Молочка, Сладости, Орехи
   - ✅ Подкатегории мебели: Вся мебель, Полки, Кассы
   - ✅ Автоматическая категоризация на основе названий

2. **Современный дизайн интерфейса:**
   - ✅ Карточки товаров с изображениями (эмодзи)
   - ✅ Умные контролы количества (кнопка "Добавить" → контролы +/-)
   - ✅ Отдельные корзины для товаров и мебели
   - ✅ Современная цветовая схема и типографика

3. **Техническая архитектура:**
   - ✅ Вложенная навигация (основные вкладки → подвкладки → подкатегории)
   - ✅ Состояние корзин сохраняется при переключении между категориями
   - ✅ Автоматическое определение подкатегорий через ProductCatalogService

### Этап 16: Улучшение системы доставки (Завершен):

1. **Отложенная доставка:**
   - ✅ Система заказов с таймерами (по умолчанию 3 минуты)
   - ✅ Очередь активных заказов с отслеживанием времени
   - ✅ Упрощенные ID заказов (#1, #2, #3 вместо сложных временных меток)

2. **UI отслеживания заказов:**
   - ✅ Подвкладка "Активные заказы" в секции "Магазин"
   - ✅ Карточки заказов с полной информацией (ID, время, товары, стоимость)
   - ✅ Таймеры обратного отсчета, обновляющиеся в реальном времени
   - ✅ Кнопки отмены заказов с возвратом 50% средств

3. **Система уведомлений:**
   - ✅ Уведомления при размещении заказа
   - ✅ Предупреждения за минуту до доставки
   - ✅ Уведомления о доставке и отмене заказов

4. **Интеграция с сохранением:**
   - ✅ Активные заказы сохраняются в SaveGameData.ActiveOrders
   - ✅ Восстановление таймеров при загрузке игры
   - ✅ Автоматическая синхронизация счетчика заказов

## Текущее состояние системы:

### Полностью работающие механики:
- ✅ Заказ товаров через компьютер с отложенной доставкой
- ✅ Отслеживание активных заказов в реальном времени
- ✅ Отмена заказов с частичным возвратом средств
- ✅ Доставка в коробках (как немедленная, так и отложенная)
- ✅ Подбор и открытие/закрытие коробок
- ✅ Размещение товаров на полках (ЛКМ/ПКМ)
- ✅ ИИ покупателей с навигацией
- ✅ Система очередей без коллизий
- ✅ Работа кассиром (нажатие E)
- ✅ Анимации действий покупателей
- ✅ Экономика (деньги игрока)
- ✅ Система сохранения/загрузки игры
- ✅ Сохранение/восстановление коробок на земле
- ✅ Сохранение/восстановление активных заказов

## ✅ НОВАЯ ФУНКЦИЯ: Система влияния цены на покупательские решения + Фиксация цен

**Реализована система динамического влияния цены товаров на покупательское поведение!**

### Что добавлено:

1. **IPurchaseDecisionService и PurchaseDecisionService**:
   - Новый сервис для оценки покупательских решений на основе цены
   - Алгоритм учитывает два фактора:
     - **Фактор доступности**: может ли покупатель позволить себе товар (на основе денег)
     - **Фактор справедливости цены**: насколько цена отличается от базовой стоимости

2. **PurchaseDecisionConfig (ScriptableObject)**:
   - Настраиваемая конфигурация для параметров системы
   - Файл: `Assets/Resources/Data/GameConfig/PurchaseDecisionConfig.asset`
   - Параметры с валидацией в Unity Inspector:
     - `basePurchaseProbability = 0.8f` - базовая вероятность покупки
     - `maxPriceMultiplier = 3.0f` - максимальное превышение цены
     - `minPurchaseProbability = 0.1f` - минимальная вероятность
     - `affordabilityThreshold = 0.3f` - порог доступности (30% от денег покупателя)
     - `enableDetailedLogging = true` - включение детального логирования

2. **✅ ФИКСАЦИЯ ЦЕН НА МОМЕНТ ВЗЯТИЯ ТОВАРА**:
   - **ShoppingItem** расширен полем `PurchasePrice` - цена на момент взятия с полки
   - **CustomerController** сохраняет цену при первом взятии товара (`CollectedQuantity == 1`)
   - **CashDeskController** использует сохраненную цену вместо текущей розничной цены
   - **Новый метод `GetCustomerPurchasePrice()`** для поиска цены в данных покупателя
   - **Система fallback**: если цена не найдена, используется текущая розничная цена
   - **Полная интеграция**: покупатель всегда платит цену на момент взятия товара

3. **Интеграция в CustomerController**:
   - Добавлена проверка цены в методе `ProcessItemPickup()`
   - Покупатель теперь может отказаться от товара из-за высокой цены
   - Товары помечаются как `UnavailableInStore = true` при отказе
   - Детальное логирование решений покупателей

3. **Исправление CashDeskController**:
   - Касса теперь использует `IRetailPriceService.GetRetailPrice()` вместо `BaseSalePrice`
   - Правильный расчет суммы с учетом установленных игроком цен
   - Улучшенное логирование с форматированием цен

4. **Регистрация в GameContext**:
   - `PurchaseDecisionService` зарегистрирован как POCO сервис
   - Доступен через dependency injection во всех компонентах

### Как работает система:

1. **При попытке взять товар с полки**:
   - Покупатель проверяет цену товара через `IRetailPriceService`
   - Вычисляется вероятность покупки на основе алгоритма
   - Генерируется случайное число для принятия решения
   - Если решение отрицательное - товар помечается как недоступный

2. **Алгоритм расчета вероятности**:
   ```
   Итоговая вероятность = Базовая вероятность × Фактор доступности × Фактор справедливости цены
   ```

3. **Фактор доступности**:
   - Если цена ≤ 30% от денег покупателя → 1.0 (полная доступность)
   - Если цена > денег покупателя → 0.0 (недоступно)
   - Промежуточные значения интерполируются

4. **Фактор справедливости цены**:
   - Если цена ≤ базовой цены → 1.0 (справедливая цена)
   - Если цена > 3× базовой цены → 0.05 (чрезмерно высокая)
   - Промежуточные значения плавно снижаются

### Результат:
- ✅ Высокие цены снижают покупательскую активность
- ✅ Покупатели с меньшими деньгами более чувствительны к ценам
- ✅ Система сбалансирована и настраиваема
- ✅ Полная интеграция с существующей архитектурой
- ✅ Детальное логирование для анализа поведения

**Теперь игрок может влиять на продажи, устанавливая разные цены на товары!**

## ✅ НОВАЯ ФУНКЦИЯ: Система точек подхода к полкам

**Добавлена возможность настройки специальных точек подхода для покупателей к полкам!**

### Что добавлено:

1. **ShelfController расширен**:
   - Добавлено поле `customerApproachPoint` - Transform точка подхода покупателей
   - Новый метод `GetCustomerApproachPosition()`:
     - Возвращает позицию customerApproachPoint, если задана
     - Fallback: позиция полки с отступом назад на 1.5 метра
     - Предупреждение в лог, если точка не настроена

2. **MultiLevelShelfController расширен**:
   - Аналогичная функциональность для многоуровневых полок
   - Поле `customerApproachPoint` и метод `GetCustomerApproachPosition()`
   - Единообразное поведение с обычными полками

3. **CustomerController обновлен**:
   - `StartGoingToShelf()` теперь использует `GetCustomerApproachPosition()`
   - `UpdateGoingToShelf()` рассчитывает расстояние до точки подхода
   - Покупатели идут к специально настроенным точкам вместо центра полки

4. **CustomerApproachPoint компонент**:
   - Вспомогательный компонент для визуализации точек подхода в редакторе
   - Gizmo показывает зеленую сферу в позиции точки
   - Стрелка показывает направление (куда должен смотреть покупатель)
   - Настраиваемые цвет, размер и видимость направления

### Как использовать:

1. **Создать точку подхода**:
   - Создать пустой GameObject рядом с полкой
   - Позиционировать в удобном месте для подхода покупателей
   - Опционально добавить `CustomerApproachPoint` для визуализации

2. **Назначить в полке**:
   - Выбрать полку (ShelfController или MultiLevelShelfController)
   - В разделе "Customer Interaction" назначить Customer Approach Point
   - Теперь покупатели будут идти к этой точке

3. **Настройка направления**:
   - Повернуть точку подхода так, чтобы transform.forward смотрел в сторону полки
   - Покупатели будут поворачиваться лицом к полке по этому направлению

### Преимущества:

- ✅ Более реалистичное поведение покупателей
- ✅ Возможность настройки удобных мест подхода к полкам
- ✅ Избежание столкновений покупателей с полками
- ✅ Визуальная помощь в редакторе через gizmo
- ✅ Гибкость настройки под любую планировку магазина
- ✅ Обратная совместимость (fallback к старому поведению)

**Покупатели теперь подходят к полкам более естественно и реалистично!**

## ✅ ИСПРАВЛЕНИЕ: Проблема с очередью после окончания обслуживания

**Проблема:** Когда очередь покупателей заканчивается и приходит новый покупатель, он встает в очередь но не начинает обслуживание, хотя является единственным.

**Причина:** Race condition между окончанием обслуживания предыдущего покупателя и присоединением нового к очереди. Система не запускала обслуживание для нового покупателя после того, как очередь становилась пустой.

### Что исправлено:

1. **Улучшена логика TryJoinQueue()**:
   - Добавлено детальное логирование процесса присоединения к очереди
   - Явная проверка условий для запуска обслуживания
   - Диагностические сообщения для отладки

2. **Исправлен ProcessNextCustomer()**:
   - Добавлена небольшая задержка (0.1s) перед финальной проверкой очереди
   - Детальное логирование состояния очереди после завершения обслуживания
   - Гарантия что новые покупатели будут обслужены

3. **Добавлен метод CheckAndStartProcessing()**:
   - Принудительная проверка и запуск обслуживания при необходимости
   - Решает race condition проблемы
   - Может вызываться для гарантированного запуска процесса

4. **Дополнительная проверка в CustomerController**:
   - `CheckServiceAfterJoiningQueue()` корутина в CustomerController
   - Запускается после успешного присоединения к очереди
   - Задержка 0.2s для синхронизации + принудительная проверка обслуживания

### Алгоритм исправления:

1. **При присоединении к очереди (TryJoinQueue)**:
   - Проверяется: `_isPlayerOperating && !_isProcessingCustomer && _cashDeskData.CurrentCustomer == null`
   - Если условия выполнены → запускается `ProcessNextCustomer()`
   - Логируется результат проверки

2. **При завершении обслуживания (ProcessNextCustomer)**:
   - Ожидание 0.1s для синхронизации
   - Повторная проверка наличия покупателей в очереди
   - Запуск обслуживания следующего покупателя

3. **Дополнительная гарантия (CheckServiceAfterJoiningQueue)**:
   - Запускается автоматически после присоединения к очереди
   - Ожидание 0.2s + вызов `CheckAndStartProcessing()`
   - Страховка от любых race conditions

### Результат:
- ✅ Новые покупатели всегда начинают обслуживание, если очередь была пуста
- ✅ Устранены race conditions между завершением и началом обслуживания  
- ✅ Добавлено детальное логирование для диагностики проблем
- ✅ Множественные механизмы защиты от зависания очереди

**Теперь очередь работает корректно в любых сценариях!**

## ✅ ДОПОЛНИТЕЛЬНОЕ ИСПРАВЛЕНИЕ: Конфликт состояний в очереди

**Проблема сохранялась:** В логах видно, что покупатель переходил из `PlacingItemsOnBelt` обратно в `WaitingInQueue`, что создавало конфликт состояний.

**Точная причина:** Race condition в `UpdateJoiningQueue()` - когда `TryJoinQueue()` немедленно запускает обслуживание и переводит покупателя в `PlacingItemsOnBelt`, но в том же кадре `UpdateJoiningQueue()` продолжает выполняться и переводит в `WaitingInQueue`.

### Что дополнительно исправлено:

1. **Защита от повторного перехода состояний в UpdateJoiningQueue()**:
   ```csharp
   if (_customerData.CurrentState == CustomerState.JoiningQueue)
   {
       ChangeState(CustomerState.WaitingInQueue);
   }
   ```
   - Переход в `WaitingInQueue` только если покупатель все еще в `JoiningQueue`
   - Предотвращает перезапись состояния если уже началось обслуживание

2. **Улучшена CheckServiceAfterJoiningQueue()**:
   ```csharp
   if (cashDesk != null && _customerData.CurrentState == CustomerState.WaitingInQueue)
   ```
   - Дополнительная проверка запускается только для ожидающих покупателей
   - Избегает лишних вызовов для уже обслуживающихся покупателей

### Исправленная последовательность:

1. **Покупатель присоединяется к пустой очереди**:
   - `TryJoinQueue()` → немедленный запуск `ProcessNextCustomer()` 
   - `StartPaymentProcess()` → переход в `PlacingItemsOnBelt`
   - `UpdateJoiningQueue()` видит что состояние изменилось → **НЕ** переходит в `WaitingInQueue`

2. **Покупатель присоединяется к занятой очереди**:
   - `TryJoinQueue()` → добавление в очередь без немедленного обслуживания
   - `UpdateJoiningQueue()` → переход в `WaitingInQueue` (правильно)
   - `CheckServiceAfterJoiningQueue()` → дополнительная проверка через 0.2s

### Результат:
- ✅ Устранен конфликт состояний `PlacingItemsOnBelt` ↔ `WaitingInQueue`
- ✅ Правильная последовательность переходов состояний
- ✅ Немедленное обслуживание для первого в пустой очереди
- ✅ Корректное ожидание для последующих покупателей

**Проблема полностью решена - нет больше конфликтующих переходов состояний!**

## ✅ НОВОЕ ИСПРАВЛЕНИЕ: Толпление покупателей у точки выхода

**Проблема:** Когда покупатели идут к ExitPoint для уничтожения, они толпятся и сталкиваются друг с другом, не дойдя до точки выхода.

**Причина:** Все покупатели идут к одной и той же позиции `_exitPoint.position`, что создает скопление NavMesh агентов в одной точке.

### Решение:

1. **Добавлены новые настройки в CustomerController**:
   ```csharp
   [Header("Exit Behavior")]
   [SerializeField] private float _exitRadius = 3f; // Радиус вокруг точки выхода для избежания толпления
   [SerializeField] private float _exitReachDistance = 2f; // Дистанция считается достижением выхода
   [SerializeField] private float _exitTimeout = 10f; // Таймаут выхода - принудительное уничтожение
   ```

2. **Персональная позиция выхода**:
   - Добавлено поле `_personalExitPosition` для хранения индивидуальной позиции
   - В `StartLeaving()` каждый покупатель получает случайную позицию в радиусе `_exitRadius` от основной точки выхода
   - Использует `UnityEngine.Random.insideUnitCircle` для равномерного распределения

3. **Улучшена логика достижения выхода**:
   - `UpdateLeaving()` проверяет расстояние до персональной позиции
   - Увеличен радиус успешного достижения до `_exitReachDistance` (2м)
   - Добавлена проверка как расстояния, так и `HasReachedDestination()`

4. **Защита от зависания**:
   - Таймаут `_exitTimeout` (10 секунд) для принудительного уничтожения
   - Если покупатель не может дойти за отведенное время - уничтожается принудительно
   - Предотвращает накопление "застрявших" покупателей

### Технические детали:

1. **Алгоритм создания персональной позиции**:
   ```csharp
   Vector2 randomOffset = UnityEngine.Random.insideUnitCircle * _exitRadius;
   _personalExitPosition = _exitPoint.position + new Vector3(randomOffset.x, 0, randomOffset.y);
   ```

2. **Проверка достижения с двойным условием**:
   ```csharp
   if (distanceToExit <= _exitReachDistance || _locomotion.HasReachedDestination())
   ```

3. **Аварийное завершение по таймауту**:
   ```csharp
   if (_stateTimer > _exitTimeout)
   {
       Debug.LogWarning($"Exit timeout reached, forcing leave");
       LeaveStore();
   }
   ```

### Настраиваемые параметры:

- **Exit Radius (3м)**: Радиус зоны вокруг точки выхода, в которой покупатели получают случайные позиции
- **Exit Reach Distance (2м)**: Дистанция до персональной позиции, при которой считается что выход достигнут
- **Exit Timeout (10с)**: Максимальное время на достижение выхода перед принудительным уничтожением

### Результат:
- ✅ Покупатели равномерно распределяются вокруг точки выхода
- ✅ Устранено толпление и столкновения у выхода
- ✅ Более реалистичное поведение - люди выходят через "зону" а не "точку"
- ✅ Защита от зависания с автоматической очисткой
- ✅ Настраиваемые параметры для балансировки
- ✅ Детальное логирование для отладки

**Теперь покупатели плавно покидают магазин без скученности у выхода!**

### 1. Расширенный PlayerInteractionController - Обработка клавиши R
- Использует существующую систему raycast для поиска размещенных объектов  
- Проверяет объекты по тегу "PlacedObject" (правильный подход)
- Активирует режим перемещения через `IPlacementService.StartRelocateMode()`
- Работает только в игровом режиме (InputMode.Game)
- Интегрируется с существующей системой dependency injection

## ✅ КРИТИЧЕСКОЕ ИСПРАВЛЕНИЕ: Клиенты уходят с товарами при продаже кассы

**Проблема:** Когда игрок продает кассу, клиенты переходят в состояние `Shopping`, но поскольку у них уже есть товары в корзине, логика в `UpdateShopping()` считает что им больше нечего покупать и они уходят из магазина с неоплаченными товарами!

**Причина:** В `UpdateShopping()` когда `GetNextItemToBuy()` возвращает `null` (все товары собраны), клиент пытается идти к кассе. Но если касс нет, он переходит в состояние `Leaving` и уходит с товарами.

### Что исправлено:

1. **Улучшена логика UpdateShopping()**:
   ```csharp
   if (hasItems)
   {
       // ИСПРАВЛЕНО: Проверяем, есть ли доступные кассы перед переходом к кассе
       FindBestCashDesk();
       
       if (_targetCashDesk != null)
       {
           ChangeState(CustomerState.GoingToCashier);
       }
       else
       {
           // Есть товары, но нет касс - ждем в состоянии покупок
           Debug.Log($"Customer has items but no cash desk available, waiting for cash desk");
           
           // Проверяем таймаут терпения
           if (_stateTimer >= _cashDeskWaitTimeout)
           {
               Debug.Log($"Patience timeout reached, leaving with items!");
               ChangeState(CustomerState.Leaving);
               return;
           }
           
           _locomotion.Stop();
           // Остаемся в состоянии Shopping - НЕ переходим к Leaving!
           return;
       }
   }
   ```

2. **Добавлен таймаут терпения клиентов**:
   - Новый параметр `_cashDeskWaitTimeout = 30f` секунд
   - Если касса не появляется за это время, клиент может уйти
   - Предотвращает бесконечное ожидание

3. **Улучшен OnCashDeskDestroyed()**:
   - Более четкие комментарии о логике обработки
   - Правильное использование состояния `Shopping` как состояния ожидания кассы
   - Детальное логирование для отладки

4. **Анимация ожидания**:
   - Клиенты могут проигрывать анимацию недовольства (`PlayWaveAnimation()`) пока ждут
   - 10% шанс каждый кадр для реалистичности
   - Визуальная обратная связь что клиенты ждут

### Алгоритм исправления:

1. **При уничтожении кассы**:
   - Клиенты с товарами переходят в состояние `Shopping` (ожидание кассы)
   - Клиенты без товаров уходят (`Leaving`)

2. **В состоянии ожидания кассы**:
   - `UpdateShopping()` проверяет наличие касс перед переходом к `GoingToCashier`
   - Если касс нет - остается в `Shopping` и ждет
   - Таймер терпения отсчитывает время ожидания

3. **При появлении новой кассы**:
   - `OnNewCashDeskAvailable()` переназначает ожидающих клиентов
   - Клиенты немедленно идут к новой кассе

4. **По истечении терпения**:
   - После 30 секунд ожидания клиент может уйти с товарами
   - Это реалистично - люди не будут ждать бесконечно

### Настраиваемые параметры:

- **Cash Desk Wait Timeout (30с)**: Максимальное время ожидания кассы перед уходом
- **Wave Animation Chance (10%)**: Вероятность анимации недовольства каждый кадр

### Результат:
- ✅ Клиенты НЕ уходят немедленно при уничтожении кассы если у них есть товары
- ✅ Реалистичное ожидание появления новой кассы
- ✅ Визуальная обратная связь через анимации ожидания
- ✅ Защита от бесконечного ожидания через таймаут терпения
- ✅ Правильная интеграция с системой переназначения клиентов
- ✅ Детальное логирование для отладки

**Теперь клиенты ведут себя реалистично - ждут новую кассу вместо кражи товаров!**

### 1. Расширенный PlayerInteractionController - Обработка клавиши R